== Configuration
Looking at the polyglot application landscape with different technology stacks, then the Spring Cloud Config server
will not survive the Kubernetes migration in the long run. Instead a more general approach must be taken.

The Spring Cloud Kubernetes incubator project extends the Spring Boot hierarchy of PropertySources by
another one that gets populated from the Kubernetes ConfigMaps and the Kubernetes Secrets.

The Spring Cloud Kubernetes Config implementation triggers the reload of the @RefreshScope annotated beans
when a change in the ConfigMap is detected. The `metadata.name` of the ConfigMap must be set to the
`spring.application.name` for the Spring Cloud Kubernetes Config implementation to load the ConfigMap as a
`PropertySource` into the application `Environment`.

=== Background
All environment specific configurations are stored in yaml or properties files in a central Git repository, which is
the backing store for the Spring Cloud Config server.

Those files follow a naming pattern:

   application.yml
   application-<spring.profile>.yml
   <spring.application.name>.yml
   <spring.application.name>-<spring.profile>.yml

The `application.yml` and `application-<spring-profile>.yml` can be used to set defaults for all microservices, either
globally or specific to an environment aka spring-sprofile.
The number of properties in those global files should be kept at an absolute minimum, because responsibility
of maintaining those global settings is not clear when multiple teams have access to those files. Ideally
they are used as a short-term workaround only, e.g. disabling a certain logger for all mciroservices because of data
privacy concerns.

A change to any of the YAML files needs to trigger an automatic step where the configuration is applied to the
microservice. For Spring Boot Java applications this can be done without having to restart the microservice, because
the Spring Cloud Kubernetes Config implementation triggers the `/refresh` endpoint and any changed Spring Bean
gets automatically reloaded. But for certain properties, a restart of the microservice is required.
For applications, not using the Spring Boot stack this feature is not available or at least works in a different
way. The goal must be to map it to the ConfigMap feature of Kubernetes to allow configuration of microservices in
different technology stacks in the same way.

Configuration changes can be applied automatically by doing a refresh or a restart of the microservice, depending
on what the service supports. In both cases several modes and parameters need to be specified to control the process:

* *rolling or phased* +
In rolling mode one instance after the other is either restarted or refreshed. Phase means the mode is applied to all
instances at once.
* *rolling instance delay* +
The time to wait when doing rolling refresh or restart for the next instance to begin with.
* *liveness & readiness delay* +
During the deployment, a liveness and readiness delay is configured. When applying a configuration change in restart
mode, the same delay must be taken into account. In refresh mode, this delay might be smaller or not present at all.

=== Solution
For all requirements from above there are already solutions in the Kubernetes world. The refresh mode is ignored by the
presented solution because it is a Spring Boot Java only feature. Instead, all pods, no matter of what technology are
treated equally, they will be restarted only.

In Kubernetes the solution is a combination of deployment options, container probes, and a special gitcontroller which
triggers a rolling update when the content of the Git repository changes.

A Kubernetes deployment defines how a container is restarted and the container probes define how long to wait for each
pod to start. All this gets triggered by a https://github.com/fabric8io/gitcontroller[gitcontroller], which needs the
microservice specific Git config repository, attached as a
https://kubernetes.io/docs/concepts/storage/volumes/#gitrepo[gitRepo] volume to the pod.

That means each commit to the Got repository leads to a rolling restart of the pods. The pre-requisite for this is
that the configuration change can be done in a forward compatible way.

By putting all config map entries into the environment of the process, we do not need the Spring Cloud Kubernetes
Config implementation to support ConfigMaps as PropertySource, instead the Spring Boot standard could be used, which
already tales properties out of the process' system envvironment.

TODO:

* The gitRepo volume change needs to trigger a YAML (or properties) to ConfigMap transformation +
https://kubernetes.io/docs/tasks/configure-pod-container/configure-pod-configmap/#create-configmaps-from-files
* The ConfigMap must to be configured to put all properties into the environment of the process +
https://kubernetes.io/docs/tasks/configure-pod-container/configure-pod-configmap/#use-configmap-defined-environment-variables-in-pod-commands
* The fabric8 gitcontroller probably needs to be extended to additionally support those steps +
https://blog.fabric8.io/additional-kubernetes-controllers-from-fabric8-you-can-use-with-your-microservice-3126a2c4c132
* What is the current state of the discussion? +
https://github.com/kubernetes/kubernetes/issues/22368

=== Migration Path
The migration process

. Phase 1
.. Switch from Eureka first to Config-Server first approach
. Phase 2
.. Use a microservice specific Git repository where the configuration is stored
.. Merge all settings from application.yml and application-<spring.profile>.yml into the microservice specific files
. Phase 3
.. Put the environment specific properties into a ConfigMap as part of the deployment
.. Allow updates to the ConfigMap at runtime

=== Open Issues

* How to handle runtime updates of the configuration when it is part of the process environment?
* What backends are available for the ConfigMap resources and how does the process look like to work with ConfigMap
changes?
* Use Spring Cloud Kubernetes Config or configure the ConfigMap to put the properties into the environment of the pod?
** https://kubernetes.io/docs/tasks/configure-pod-container/configure-pod-configmap/#configure-all-key-value-pairs-in-a-configmap-as-pod-environment-variables
** Putting it into the environment has the issue that the process needs to be restarted to make changes available to
the process.
* When a change to the environment specific properties triggers an automatic config update, how to define whether a
service is restarted or whether the /refresh endpoint is called only? This depends on the property, e.g. changing
the webcontainer's HTTP port requires a restart, whereas a Hystrix timeout change can be applied on the fly.
* What about text or binary files in the config? Excel configuration files, WSDL files, ...
* Shall we ignore the Spring Boot refresh mechanism and do a restart for all config changes so that there are no
differences between Spring Boot and other stacks?
* Do we need to switch from YAML to properties?
* How to deal with stable/maintenance branches?